<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>solidity入门 | 许小墨のBlog</title><meta name="author" content="许小墨,1440023258@qq.com"><meta name="copyright" content="许小墨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Solidty 开发环境 Solidity编辑器：Solidity编辑器是一种专门用于编写和编辑Solidity代码的编辑器。常用的Solidity编辑器包括Visual Studio Code、Atom和Sublime Text。 以太坊开发环境：以太坊开发环境（Ethereum Development Environment）是一种专门用于以太坊开发的工具，可以用于部署、测试和调试智能合约。常"><meta property="og:type" content="article"><meta property="og:title" content="solidity入门"><meta property="og:url" content="https://angelxyj.github.io/posts/14d570ad.html"><meta property="og:site_name" content="许小墨のBlog"><meta property="og:description" content="Solidty 开发环境 Solidity编辑器：Solidity编辑器是一种专门用于编写和编辑Solidity代码的编辑器。常用的Solidity编辑器包括Visual Studio Code、Atom和Sublime Text。 以太坊开发环境：以太坊开发环境（Ethereum Development Environment）是一种专门用于以太坊开发的工具，可以用于部署、测试和调试智能合约。常"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://angelxyj.github.io/img/1.png"><meta property="article:published_time" content="2023-07-08T12:50:34.000Z"><meta property="article:modified_time" content="2024-10-01T16:38:42.335Z"><meta property="article:author" content="许小墨"><meta property="article:tag" content="区块链"><meta property="article:tag" content="Web3.0"><meta property="article:tag" content="solidity"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://angelxyj.github.io/img/1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://angelxyj.github.io/posts/14d570ad.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/favicon-16x16.png"><link rel="mask-icon" href="/img/siteicon/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!0},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: 许小墨",link:"链接: ",source:"来源: 许小墨のBlog",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"solidity入门",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-10-01 16:38:42"}</script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach((e=>{n.setAttribute(e,t[e])})),document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{const e=document.getElementById("loading-box"),d=document.body,o=()=>{d.style.overflow="",e.classList.add("loaded")},t=()=>{d.style.overflow="hidden",e.classList.remove("loaded")};t(),window.addEventListener("load",(()=>{o()})),document.addEventListener("pjax:send",(()=>{t()})),document.addEventListener("pjax:complete",(()=>{o()}))})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">198</div></a><a href="/%E6%A0%87%E7%AD%BE/"><div class="headline">标签</div><div class="length-num">183</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">42</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li><li><a class="site-page child" href="/poems/"><i class="fa-fw fas fa-book"></i> <span>文学鉴赏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i> <span>关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-compass"></i> <span>关于</span></a></li><li><a class="site-page child" href="/sponsor/"><i class="fa-fw fas fa-thumbs-up"></i> <span>打赏</span></a></li><li><a class="site-page child" href="/resume/"><i class="fa-fw fas fa-book"></i> <span>简历</span></a></li><li><a class="site-page child" href="/TodoList"><i class="fa-fw fab fa-internet-explorer"></i> <span>计划</span></a></li><li><a class="site-page child" href="/ChatGPT/"><i class="fa-fw fas fa-fan"></i> <span>GPT</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i> <span>留言板</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('/img/1.png')"><nav id="nav"><span id="blog-info"><a href="/" title="许小墨のBlog"><span class="site-name">许小墨のBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li><li><a class="site-page child" href="/poems/"><i class="fa-fw fas fa-book"></i> <span>文学鉴赏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i> <span>关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-compass"></i> <span>关于</span></a></li><li><a class="site-page child" href="/sponsor/"><i class="fa-fw fas fa-thumbs-up"></i> <span>打赏</span></a></li><li><a class="site-page child" href="/resume/"><i class="fa-fw fas fa-book"></i> <span>简历</span></a></li><li><a class="site-page child" href="/TodoList"><i class="fa-fw fab fa-internet-explorer"></i> <span>计划</span></a></li><li><a class="site-page child" href="/ChatGPT/"><i class="fa-fw fas fa-fan"></i> <span>GPT</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i> <span>留言板</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">solidity入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-08T12:50:34.000Z" title="发表于 2023-07-08 12:50:34">2023-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-01T16:38:42.335Z" title="更新于 2024-10-01 16:38:42">2024-10-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/Web3-0/">Web3.0</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="solidity入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Solidty-开发环境"><a href="#Solidty-开发环境" class="headerlink" title="Solidty 开发环境"></a>Solidty 开发环境</h1><ol><li>Solidity编辑器：Solidity编辑器是一种专门用于编写和编辑Solidity代码的编辑器。常用的Solidity编辑器包括Visual Studio Code、Atom和Sublime Text。</li><li>以太坊开发环境：以太坊开发环境（Ethereum Development Environment）是一种专门用于以太坊开发的工具，可以用于部署、测试和调试智能合约。常用的以太坊开发环境包括Truffle、Embark和Buidler （Hardhat）。</li><li>以太坊虚拟机：以太坊虚拟机（Ethereum Virtual Machine，EVM）是以太坊区块链的运行环境，用于在以太坊区块链上运行智能合约。常用的以太坊虚拟机包括ganache-cli和geth。</li><li>以太坊浏览器：以太坊浏览器是一种用于浏览、搜索和交互以太坊区块链数据的工具。常用的以太坊浏览器包括Etherscan、Etherchain和Blockchain Explorer。</li></ol><h2 id="Hardhat"><a href="#Hardhat" class="headerlink" title="Hardhat"></a><a target="_blank" rel="noopener" href="https://hardhat.org/">Hardhat</a></h2><p><a target="_blank" rel="noopener" href="https://hardhat.org/">https://hardhat.org/</a></p><p>Hardhat是目前最好的框架之一，支持快速测试，同时提供了最好的教程和最简单的集成。 老实说，每个喜欢JS框架的人都应该在某个时候试用Hardhat。它真的很容易上手，具有快速的测试， 而且入门非常简单。Hardhat的Discord也总是非常迅速地回答问题，因此，如果遇到问题，你 总是可以寻求帮助。Hathat使用Waffle和Ethers.js进行测试 —— 可以说是更好的JavaScript 智能合约框架 —— 开发人员的生活质量确实能得到一些改善。</p><p>Hardhat还可以与OpenZeppelin的可升级智能合约插件直接集成，这是一个巨大的胜利。 这个项目给人一种很棒的感觉：很干净。它会执行你想要的操作。真的很快。该项目正在不断改进， Hardhat显然致力于使智能合约开发人员的生活更轻松。</p><p>Hardhat概要：</p><p>ETH基金会资助的项目，以前的名字是Builder<br>技术：Javascript，Web3.js和Ethers.js插件，OpenZeppelin可升级合同插件， Etherscan插件，区块链分叉<br>区块链：Hardhat运行时环境&#x2F;本地、测试网、主网<br>测试支持：Waffle<br>维护：非常活跃<br>支持：活跃<br>开源</p><h2 id="Truffle"><a href="#Truffle" class="headerlink" title="Truffle"></a>Truffle</h2><p><a target="_blank" rel="noopener" href="https://trufflesuite.com/">https://trufflesuite.com/</a></p><p>几年来Truffle一直是以太坊智能合约的默认开发框架，这是有充分理由的。 Truffle是一个强大的框架，为其他许多人树立了标准。你很容易找到使用此平台的项目， 因此查找示例很容易。Truffle也可以很容易地与它的姊妹工具Drizzle和Ganache集成在一起。 特别是Ganache，它是工程师运行本地区块链的最流行方法之一。对于那些正在寻找更多工具的人， 你可以为升级的Truffle团队帐户付费，并可以访问智能合约的持续集成，可视化部署和监视。 Truffle还可以与OpenZeppelin的可升级智能合约插件直接集成，这是一个巨大的胜利。 Truffle的开发团队显然是一群有才华的工程师，他们想要使世界成为一个更好的智能合约场所。</p><p>Truffle测试的运行速度不如hardhat那样快，并且由于用户数量众多，获得支持可能很困难。 我很期待看到被ConsenSys收购后他们将如何改善这个项目。Truffle的文档质量似乎开始下降 并且很难遵循，但是如果你用Google搜索遇到的错误，则很可能会遇到遇到该错误并已解决的人。 我发现改善项目的一些最佳方法是在GitHub上发布问题。无论如何，保持生态系统不断壮大是我们 的开源职责！</p><p>由于几乎每个人都熟悉它，因此获得同行的支持通常很容易。我真的希望看到团队在这个项目 上获得更多支持，因为他们有这么多用户。我希望他们能看到本文并致力于改善其文档，以使 其能够继续作为测试和部署智能合约的首选平台之一。</p><p>Truffle概要：</p><p>使用最广泛的平台；最近被ConsenSys收购（2020年11月）<br>技术：Javascript，Web3.js，OpenZeppelin可升级合同插件，Etherscan插件，区块链分叉<br>区块链：Ganache &#x2F;本地，测试网，主网<br>有测试<br>维护：非常活跃<br>支持：活跃<br>开源，可以付费升级</p><h2 id="Embark"><a href="#Embark" class="headerlink" title="Embark"></a>Embark</h2><p>Embark是整个DAPP框架。这是一个全栈的区块链平台。在Gitter的 一些帮助下，我能够将Chainlink合约部署到Kovan网络。它带有一个UI，允许你在GUI中与区块链 和合约进行交互。Embark有一段学习曲线，我没有花足够的时间来克服，但它展示了其潜力。这就是 为什么我想将其包括在这里的原因，因为我觉得我没有完全消化很多东西。</p><p>我希望看到人们更多地尝试该框架并看到其功能。由于在项目中花费的时间有限，我觉得我可能 无法在这里做到公正。我确实认为将前端与后端解耦仍然是最佳做法，但是如果你需要启动一个 具有良好前端的项目并且不关心解耦，那么您应该100％尝试这个项目。</p><p>这是一个很酷的项目，如果有人喜欢Hardhat和Truffle，并且又想与全栈解决方案集成，那么我愿意 推荐Embark给他。</p><p>Embark概要：</p><p>具有大量功能的JavaScript框架用于前端开发<br>技术：JavaScript，Web3.js，代理合约支持<br>区块链：Ganache &#x2F;本地，测试网，主网<br>支持测试<br>维护：轻度活跃<br>支持：活跃<br>开源</p><h1 id="Remix基本使用"><a href="#Remix基本使用" class="headerlink" title="Remix基本使用"></a>Remix基本使用</h1><p>Remix 是以太坊智能合约编程语言Solidity IDE，其实基于浏览器的IDE，有一个很大的好处就是不用安装，打开即用。<br><a target="_blank" rel="noopener" href="https://remix.ethereum.org/">官网</a> <a target="_blank" rel="noopener" href="https://remix.ethereum.org/%E3%80%82">https://remix.ethereum.org/。</a></p><h2 id="Remix基本功能"><a href="#Remix基本功能" class="headerlink" title="Remix基本功能"></a>Remix基本功能</h2><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208134636521.png" alt="image-20221208134636521"></p><h2 id="合约创建"><a href="#合约创建" class="headerlink" title="合约创建"></a>合约创建</h2><ol><li><p>如上图创建一个空的工作空间</p></li><li><p>在工作空间下创建一个智能合约文件,ex: <code>HelloWord.sol</code></p><ul><li>智能合约文件以<code>.sol</code>结尾，</li><li>文件名采用大驼峰命名法</li><li>文件名和合约名保持一致</li></ul></li><li><p>编写合约代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT; </span><br><span class="line">// 智能合约的许可协议</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">// 智能合约的适用版本</span><br><span class="line">contract HelloWord &#123;</span><br><span class="line">    string name;</span><br><span class="line">    function get() public  view returns (string memory)&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    function set (string memory _name)  public &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208140310359.png" alt="image-20221208140310359"></p></li></ol><h2 id="合约编译"><a href="#合约编译" class="headerlink" title="合约编译"></a>合约编译</h2><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208140810607.png" alt="image-20221208140810607"></p><p>编译结果：</p><p>目录产生一个<code>artifacts</code> 文件夹</p><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208140957454.png" alt="image-20221208140957454"></p><h2 id="合约部署"><a href="#合约部署" class="headerlink" title="合约部署"></a>合约部署</h2><ol><li><p>通过第四个菜单进入部署界面</p></li><li><p>选择部署环境</p></li><li><p>选择部署合约的账户地址</p></li><li><p>设置gas限制</p></li><li><p>选择要部署的合约</p></li><li><p><code>deploy</code>按钮进行部署</p><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208141436813.png" alt="image-20221208141436813"></p></li></ol><p>部署成功效果</p><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208141815165.png" alt="image-20221208141815165"></p><h2 id="合约调试"><a href="#合约调试" class="headerlink" title="合约调试"></a>合约调试</h2><ol><li>通过函数的返回值查看变量</li></ol><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208142340517.png" alt="image-20221208142340517"></p><ol start="2"><li>event Log</li></ol><p>​ solidity默认没有consol.log 或者 print 类似的事件系统 但是我们可以通过，注册事件查看对应的log日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line">    event Log(address);</span><br><span class="line">    event Log(uint);</span><br><span class="line"></span><br><span class="line">    function doSomething() public &#123;</span><br><span class="line">        uint timestamp = block.timestamp; // Current block timestamp</span><br><span class="line">        address sender = msg.sender; // address of the caller</span><br><span class="line">        emit Log(timestamp);</span><br><span class="line">        emit Log(sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208145721522.png" alt="image-20221208145721522"></p><h1 id="本地部署ReMix-IDE"><a href="#本地部署ReMix-IDE" class="headerlink" title="本地部署ReMix IDE"></a>本地部署ReMix IDE</h1><p>在线Remix访问缓慢，如果你有很好的网络环境也可以本地部署一套。<br>在本地部署Remix需要准备两个东西：一个是Remix-project，可以理解为Remix的前端；另一个是Remixd，可以理解为Remix的后端，它们的Github仓库地址分别是：<br><a target="_blank" rel="noopener" href="https://github.com/ethereum/remix-project">https://github.com/ethereum/remix-project</a><br><a target="_blank" rel="noopener" href="https://github.com/ethereum/remix-project/tree/master/libs/remixd">https://github.com/ethereum/remix-project/tree/master/libs/remixd</a></p><h2 id="Docker方式安装"><a href="#Docker方式安装" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h2><p>如果要运行合并到主分支中的最新更改，请运行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull remixproject/remix<span class="literal">-ide</span>:latest</span><br><span class="line">docker run <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">80</span> remixproject/remix<span class="literal">-ide</span>:latest</span><br></pre></td></tr></table></figure><p>如果你想运行最新的 remix-live 版本运行。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull remixproject/remix<span class="literal">-ide</span>:remix_live</span><br><span class="line">docker run <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">80</span> remixproject/remix<span class="literal">-ide</span>:remix_live</span><br></pre></td></tr></table></figure><h2 id="docker-compose方式安装"><a href="#docker-compose方式安装" class="headerlink" title="docker-compose方式安装"></a>docker-compose方式安装</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker<span class="literal">-compose</span> pull</span><br><span class="line">docker<span class="literal">-compose</span> up <span class="literal">-d</span></span><br></pre></td></tr></table></figure><h2 id="部署-Remixd"><a href="#部署-Remixd" class="headerlink" title="部署 Remixd"></a>部署 Remixd</h2><p>Remixd 的安装使用步骤如下：</p><p>1.通过 npm 或者 yarn 安装 Remixd（建议用yarn）</p><p>npm 命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> @remix<span class="literal">-project</span>/remixd</span><br><span class="line">yarn add global @remix<span class="literal">-project</span>/remixd</span><br></pre></td></tr></table></figure><p>2.启动 Remix-IDE</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remixd <span class="literal">-s</span> ./shared_project <span class="literal">-u</span> http://localhost:<span class="number">8080</span></span><br></pre></td></tr></table></figure><p>3.在 Remix-IDE 上点两下</p><p>一个点 Solidity，选择相应环境；另一个点 Connect to Localhost，连接本地环境</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22208307/1668418016050-d2ebc317-82b6-4c3d-9ad5-81f3718bcd3a.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22208307/1668418041013-6189ebcf-06b2-44ef-8ab4-04b6e78b6739.png?x-oss-process=image/resize,w_1500,limit_0"></p><h1 id="Solidity基础介绍"><a href="#Solidity基础介绍" class="headerlink" title="Solidity基础介绍"></a>Solidity基础介绍</h1><h2 id="认识一个最简单的存储合约"><a href="#认识一个最简单的存储合约" class="headerlink" title="认识一个最简单的存储合约"></a>认识一个最简单的存储合约</h2><p><img src="https://gitee.com/fcjun/image/raw/master/img/202212141037281.png" alt="image-20221214103704773"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT; </span><br><span class="line">// 智能合约的许可协议</span><br><span class="line">pragma solidity ^0.8.7;</span><br><span class="line">// 智能合约的适用版本</span><br><span class="line">import &quot;&quot;;</span><br><span class="line">// 导入</span><br><span class="line"></span><br><span class="line">contract HelloWord &#123;</span><br><span class="line">    string name;</span><br><span class="line">    // 状态变量  </span><br><span class="line">    // 函数</span><br><span class="line">    function get() public  view returns (string memory)&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    function set (string memory _name)  public &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="授权协议"><a href="#授权协议" class="headerlink" title="授权协议"></a>授权协议</h3><ul><li>默认情况下，在发布源代码时加入机器可读许可证说明是很重要的。由于提供源代码总是涉及版权方面的法律问题，Solidity 编译器鼓励使用机器可读的 SPDX 许可证标识符,比如：<code>// SPDX-License-Identifier: MIT</code></li></ul><p>至于什么是SPDX 大家可以参考如下资料：</p><p>首先是SPDX，这是个组织名，其网站为：<br><a target="_blank" rel="noopener" href="https://spdx.org/licenses/">SPDX 许可证列表 |软件包数据交换 （SPDX）</a><br>SPDX-License-Identifier 组合起来就是在指SPDX的许可证列表<br>后面的格式为 ：+ SPDX的许可证列表中的某个许可证</p><p>比如上面例子中的MIT 许可：</p><p>MIT 基本信息<br>全名：MIT License <a target="_blank" rel="noopener" href="https://spdx.org/licenses/MIT.html">麻省理工学院许可证</a> 标志符：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/MIT%E8%A8%B1%E5%8F%AF%E8%AD%89">MIT</a><br>MIT的具体内容<br>特此免费授予获得（“软件”）副本的任何人不受限制地处理本软件的许可，包括但不限于使用、复制、修改、合并、发布、分发、再许可和&#x2F;或出售本软件副本的权利</p><h3 id="Solidity版本限制"><a href="#Solidity版本限制" class="headerlink" title="Solidity版本限制"></a>Solidity版本限制</h3><ul><li>第二行是告诉编译器源代码所适用的Solidity版本为&gt;&#x3D;0.7.0 及 &lt;0.9.0 。这样的说明是为了确保合约不会在新的编译器版本中发生异常的行为。关键字 <code>pragma</code> 是告知编译器如何处理源代码的通用指令</li></ul><h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><p>在一个去中心化的世界，我们的程序并不紧紧活一台机器的CPU 上, 在一个去中心化的世界是由很多节点组成的P2P 网络。合约代码会在各节点上[<a target="_blank" rel="noopener" href="https://ethereum.org/en/developers/docs/nodes-and-clients/">Full Node</a>]单独运行，而事实上P2P的各节点相互之间都不信任的，所以每个节点都会存一份自己的状态（Distributed Ledger,分布式账本），在该示例就是name，当调用set()的时候，大家都改变了name，此时需要一种共识机制（PoS），如果PoS认为name合法，此次调用完成。 否则回滚上一个name的值，因此每一次改变状态变量的调用都是以一个事务Transcation来执行。</p><h2 id="Api文档"><a href="#Api文档" class="headerlink" title="Api文档"></a>Api文档</h2><p><a target="_blank" rel="noopener" href="https://solidity-by-example.org/">https://solidity-by-example.org/</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p><strong>局部变量</strong></p></li><li><ul><li>在函数内部声明</li><li>不存储到链上</li></ul></li><li><p><strong>状态变量</strong></p></li><li><ul><li>在函数外部声明</li><li>状态变量是永久地存储在链上的值。</li></ul></li><li><p><strong>全局变量</strong></p></li><li><ul><li>内置提供有关区块链的信息比如<code>block</code>、<code>msg</code>等</li></ul></li></ul><p>全局变量</p><p>这些是全局工作区中存在的特殊变量，提供有关区块链和交易属性的信息。</p><table><thead><tr><th align="left">名称</th><th align="left">返回</th></tr></thead><tbody><tr><td align="left">blockhash(uint blockNumber) returns (bytes32)</td><td align="left">给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。</td></tr><tr><td align="left">block.coinbase (address payable)</td><td align="left">当前区块矿工的地址</td></tr><tr><td align="left">block.difficulty (uint)</td><td align="left">当前区块的难度</td></tr><tr><td align="left">block.gaslimit (uint)</td><td align="left">当前区块的gaslimit</td></tr><tr><td align="left">block.number (uint)</td><td align="left">当前区块的number</td></tr><tr><td align="left">block.timestamp (uint)</td><td align="left">当前区块的时间戳，为unix纪元以来的秒</td></tr><tr><td align="left">gasleft() returns (uint256)</td><td align="left">剩余 gas</td></tr><tr><td align="left">msg.data (bytes calldata)</td><td align="left">完成 calldata</td></tr><tr><td align="left">msg.sender (address payable)</td><td align="left">消息发送者 (当前 caller)</td></tr><tr><td align="left">msg.sig (bytes4)</td><td align="left">calldata的前四个字节 (function identifier)</td></tr><tr><td align="left">msg.value (uint)</td><td align="left">当前消息的wei值</td></tr><tr><td align="left">now (uint)</td><td align="left">当前块的时间戳</td></tr><tr><td align="left">tx.gasprice (uint)</td><td align="left">交易的gas价格</td></tr><tr><td align="left">tx.origin (address payable)</td><td align="left">交易的发送方</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function doSomething() public view returns(uint, address) &#123;</span><br><span class="line"></span><br><span class="line">        // 内置全局变量</span><br><span class="line">        uint timestamp = block.timestamp; // 获取区块时间戳</span><br><span class="line">        address sender = msg.sender; // 获取区块地址</span><br><span class="line">        return (timestamp,sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208152548299.png" alt="image-20221208152548299"></p><p>状态变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line">    uint public nun = 123;</span><br><span class="line"></span><br><span class="line">    function doSomething() public&#123;</span><br><span class="line">        nun ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208152817271.png" alt="image-20221208152817271"></p><p>局部变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line">    function doSomething() public pure  returns(uint)&#123;</span><br><span class="line">        uint num = 123;</span><br><span class="line">        num ++;</span><br><span class="line">        // 局部变量不保存每次使用都重置</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在为变量命名时，请记住以下规则。</p><ul><li>不应使用 Solidity 保留关键字作为变量名。例如，<code>break</code>或<code>boolean</code>变量名无效。</li><li>不应以数字(0-9)开头，必须以字母或下划线开头。例如，<code>123test</code>是一个无效的变量名，但是<code>_123test</code>是一个有效的变量名。</li><li>变量名区分大小写。例如，<code>Name</code>和<code>name</code>是两个不同的变量。</li></ul><h2 id="Solidity-可见性修饰符"><a href="#Solidity-可见性修饰符" class="headerlink" title="Solidity 可见性修饰符"></a><strong>Solidity 可见性修饰符</strong></h2><p>1.public – 所有合约与账号都可以调用<br>2.private -只有在定义该函数的合约可以调用<br>3.internal- 当前合约或者继承该合约的，类似java 里面的protected 关键字。<br>4.external – 只有其他合约或者账号可以调用,定义该函数的合约不能调用,除非使用 this 关键字</p><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208153812857.png" alt="image-20221208153812857"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p>函数是代码的可执行单元。函数通常在合约内部定义，但也可以在合约外定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Storage &#123;</span><br><span class="line">    function set() public &#123; // 定义函数</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function OutsideFunc(uint x) pure returns (uint) &#123;</span><br><span class="line">    return x * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Solidity有两个关键字与函数输出相关：return和returns，他们的区别在于：</p><blockquote><p>returns加在函数名后面，用于声明返回的变量类型及变量名。</p><p>return用于函数主体中，返回指定的变量。</p></blockquote></li><li><p>view和pure的用法</p><blockquote><p>getter 类型的函数可以被view 或者 pure 修饰。 view 修饰的函数不能改变状态变量。pure 则既不能改变状态变量，也不取读取状态变量。</p></blockquote></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract ViewPureTest &#123;</span><br><span class="line">    uint public x = 1;</span><br><span class="line">    // 不能改变状态变量.</span><br><span class="line">    function addToX(uint y) public view returns (uint) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //函数中没有任何状态变量出现。</span><br><span class="line">    function add(uint i, uint j) public pure returns (uint) &#123;</span><br><span class="line">        return i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们无法确定该用view还是pure时，remix会给我们完善的提示信息</p><h2 id="错误Errors"><a href="#错误Errors" class="headerlink" title="错误Errors"></a>错误Errors</h2><blockquote><ul><li><pre><code>assert(bool condition)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  − 如果不满足条件，此方法调用将导致一个无效的操作码，对状态所做的任何更改将被还原。这个方法是用来处理内部错误的。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- `require(bool condition)` − 如果不满足条件，此方法调用将恢复到原始状态。此方法用于检查输入或外部组件的错误。</span><br><span class="line"></span><br><span class="line">- `require(bool condition, string memory message)` − 如果不满足条件，此方法调用将恢复到原始状态。此方法用于检查输入或外部组件的错误。它提供了一个提供自定义消息的选项。</span><br><span class="line"></span><br><span class="line">- `revert()` − 此方法将中止执行并将所做的更改还原为执行前状态。</span><br><span class="line"></span><br><span class="line">- `revert(string memory reason)` − 此方法将中止执行并将所做的更改还原为执行前状态。它提供了一个提供自定义消息的选项。</span><br><span class="line"></span><br><span class="line">回退状态：但是gas费用是需要消耗</span><br><span class="line"></span><br><span class="line">assert 合约内部错误</span><br><span class="line"></span><br><span class="line">require 外部参数错误</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">参数被2整除</span><br></pre></td></tr></table></figure></code></pre></li></ul></blockquote><p>assert 内部错误</p><p>Solidity 为应对失败，允许用户定义 <code>error</code> 来描述错误的名称和数据。 跟用错误字符串相比， <code>error</code> 更便宜并且允许你编码额外的数据，还可以用 NatSpec 为用户去描述错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">error NotFoundUser(address account, uint256 uid);</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line">    mapping(address =&gt; uint256) users;</span><br><span class="line"></span><br><span class="line">    function getUser(address _account, uint256 _uid) public view &#123;</span><br><span class="line">        uint256 uid = users[msg.sender];</span><br><span class="line">        if (uid &lt; _uid) &#123;</span><br><span class="line">            revert NotFoundUser(_account, _uid);</span><br><span class="line">        &#125;</span><br><span class="line">        // ...</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h2 id="事件Event"><a href="#事件Event" class="headerlink" title="事件Event"></a>事件Event</h2><p>事件是能方便地调用以太坊虚拟机日志功能的接口。</p><p>solidity默认没有consol.log 或者 print 类似的事件系统 但是我们可以通过，注册事件查看对应的log日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Variables &#123;</span><br><span class="line"></span><br><span class="line">    event Log(address);</span><br><span class="line">    event Log(uint);</span><br><span class="line"></span><br><span class="line">    function doSomething() public &#123;</span><br><span class="line">        uint timestamp = block.timestamp; // Current block timestamp</span><br><span class="line">        address sender = msg.sender; // address of the caller</span><br><span class="line">        emit Log(timestamp);</span><br><span class="line">        emit Log(sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208145721522.png" alt="image-20221208145721522"></p><h1 id="变量的数据位置"><a href="#变量的数据位置" class="headerlink" title="变量的数据位置"></a>变量的数据位置</h1><h2 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h2><p>在合约中声明和使用的变量都有一个数据位置，指明变量值应该存储在哪里。合约变量的数据位置将会影响Gas消耗量。</p><p>Solidity 提供4种类型的数据位置。</p><ul><li>Storage</li><li>Memory</li><li>Calldata</li><li>Stack</li></ul><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>该存储位置存储永久数据，这意味着该数据可以被合约中的所有函数访问。可以把它视为计算机的硬盘数据，所有数据都永久存储。</p><p>保存在存储区(Storage)中的变量，以智能合约的状态存储，并且在函数调用之间保持持久性。与其他数据位置相比，存储区数据位置的成本较高。</p><ul><li>存储中的数据是永久存在的。存储是一个key&#x2F;value库</li><li>存储中的数据写入区块链，因此会修改状态，这也是存储使用成本高的原因。</li><li>占用一个256位的槽需要消耗20000 gas</li><li>修改一个已经使用的存储槽的值，需要消耗5000 gas</li><li>当清零一个存储槽时，会返还一定数量的gas</li><li>存储按256位的槽位分配，即使没有完全使用一个槽位，也需要支付其开销</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        uint256 foo;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(uint256 =&gt; MyStruct) public myStructs;</span><br><span class="line"></span><br><span class="line">    function funcStorage(uint8 _idx, uint _val) public &#123;</span><br><span class="line">        // 从映射中获取结构体,storage 变量改变会影响状态变量的值</span><br><span class="line">        MyStruct storage myStruct = myStructs[_idx];</span><br><span class="line">        myStruct.foo = _val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>内存位置是临时数据，比存储位置便宜。它只能在函数中访问。</p><p>通常，内存数据用于保存临时变量，以便在函数执行期间进行计算。一旦函数执行完毕，它的内容就会被丢弃。你可以把它想象成每个单独函数的内存(RAM)。</p><ul><li>内存是一个字节数组，槽大小位256位（32字节）</li><li>数据仅在函数执行期间存在，执行完毕后就被销毁</li><li>读或写一个内存槽都会消耗3gas</li><li>为了避免矿工的工作量过大，22个操作之后的单操作成本会上涨</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract DataLocations &#123;</span><br><span class="line">    struct MyStruct &#123;</span><br><span class="line">        uint256 foo;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(uint256 =&gt; MyStruct) public myStructs;</span><br><span class="line"></span><br><span class="line">    function funcStorage(uint8 _idx, uint _val) public view returns (MyStruct memory) &#123;</span><br><span class="line">        // 从映射中获取结构体,storage 变量改变会影响状态变量的值</span><br><span class="line">        MyStruct memory myStruct = myStructs[_idx];</span><br><span class="line">        myStruct.foo = _val;</span><br><span class="line">        return myStruct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Calldata"><a href="#Calldata" class="headerlink" title="Calldata"></a>Calldata</h3><p>Calldata是不可修改的非持久性数据位置，所有传递给函数的值，都存储在这里。此外，Calldata是外部函数的参数(而不是返回参数)的默认位置。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>堆栈是由EVM (Ethereum虚拟机)维护的非持久性数据。EVM使用堆栈数据位置在执行期间加载变量。堆栈位置最多有1024个级别的限制。</p><p>可以看到，要永久性存储，可以保存在存储区(Storage)。</p><h2 id="数据位置规则"><a href="#数据位置规则" class="headerlink" title="数据位置规则"></a>数据位置规则</h2><h3 id="规则1-–-状态变量"><a href="#规则1-–-状态变量" class="headerlink" title="规则1 – 状态变量"></a>规则1 – 状态变量</h3><p>状态变量总是存储在存储区中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   // storage     </span><br><span class="line">   uint stateVariable;  </span><br><span class="line">   uint[] stateArray;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>此外，不能显式地标记状态变量的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   uint storage stateVariable; // 错误  </span><br><span class="line">   uint[] memory stateArray; // 错误  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="规则2-–-函数参数与返回值"><a href="#规则2-–-函数参数与返回值" class="headerlink" title="规则2 – 函数参数与返回值"></a>规则2 – 函数参数与返回值</h3><p>函数参数包括返回参数都存储在内存中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;  </span><br><span class="line"></span><br><span class="line">   // storage     </span><br><span class="line">   uint stateVariable;  </span><br><span class="line">   uint[] stateArray;  </span><br><span class="line"></span><br><span class="line">   function calculate(uint num1, uint num2) public pure returns (uint result) &#123;</span><br><span class="line">       return num1 + num2</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>此处，函数参数 <code>uint num1</code> 与 <code>uint num2</code>，返回值 <code>uint result</code> 都存储在内存中。</p><h3 id="规则3-–-局部变量"><a href="#规则3-–-局部变量" class="headerlink" title="规则3 – 局部变量"></a>规则3 – 局部变量</h3><p>值类型的局部变量存储在内存中。但是，对于引用类型，需要显式地指定数据位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;  </span><br><span class="line"></span><br><span class="line">contract Locations &#123;  </span><br><span class="line"></span><br><span class="line">  /* 此处都是状态变量 */  </span><br><span class="line"></span><br><span class="line">  // 存储在storage中  </span><br><span class="line">  bool flag;  </span><br><span class="line">  uint number;  </span><br><span class="line">  address account;  </span><br><span class="line"></span><br><span class="line">  function doSomething() public  &#123;  </span><br><span class="line"></span><br><span class="line">    /* 此处都是局部变量  */  </span><br><span class="line"></span><br><span class="line">    // 值类型</span><br><span class="line">    // 所以它们被存储在内存中</span><br><span class="line">    bool flag2;  </span><br><span class="line">    uint number2;  </span><br><span class="line">    address account2;  </span><br><span class="line"></span><br><span class="line">    // 引用类型，需要显示指定数据位置，此处指定为内存</span><br><span class="line">    uint[] memory localArray;        </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>不能显式覆盖具有值类型的局部变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() public  &#123;  </span><br><span class="line"></span><br><span class="line">  /* 此处都是局部变量  */  </span><br><span class="line">  // 值类型</span><br><span class="line">  bool memory flag2;  // 错误</span><br><span class="line">  uint Storage number2;  // 错误 </span><br><span class="line">  address account2;  </span><br><span class="line"></span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="规则4-–-外部函数的参数"><a href="#规则4-–-外部函数的参数" class="headerlink" title="规则4 – 外部函数的参数"></a>规则4 – 外部函数的参数</h3><p>外部函数的参数(不包括返回参数)存储在Calldata中。</p><h2 id="赋值的数据位置规则"><a href="#赋值的数据位置规则" class="headerlink" title="赋值的数据位置规则"></a>赋值的数据位置规则</h2><h1 id="Solidity数据类型"><a href="#Solidity数据类型" class="headerlink" title="Solidity数据类型"></a>Solidity数据类型</h1><p>Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型。</p><p>Solidity中，变量类型有以下几大类：</p><ul><li>值类型</li><li>地址类型</li><li>引用类型</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22208307/1668480555162-4b659935-9b30-459d-8ed8-cd5a65c14de4.png"></p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><table><thead><tr><th align="left">类型</th><th align="left">保留字</th><th align="left">取值</th></tr></thead><tbody><tr><td align="left">布尔型</td><td align="left">bool</td><td align="left">true&#x2F;false</td></tr><tr><td align="left">整型</td><td align="left">int&#x2F;uint</td><td align="left">有符号整数&#x2F;无符号整数。</td></tr><tr><td align="left">整型</td><td align="left">int8 to int256</td><td align="left">8位到256位的带符号整型数。int256与int相同。</td></tr><tr><td align="left">整型</td><td align="left">uint8 to uint256</td><td align="left">8位到256位的无符号整型。uint256和uint是一样的。</td></tr><tr><td align="left">定长浮点型</td><td align="left">fixed&#x2F;unfixed</td><td align="left">有符号和无符号的定长浮点型</td></tr><tr><td align="left">定长浮点型</td><td align="left">fixedMxN</td><td align="left">带符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。</td></tr><tr><td align="left">定长浮点型</td><td align="left">ufixedMxN</td><td align="left">无符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，从8到256。N可以是0到80。fixed与fixed128x18相同。</td></tr></tbody></table><h2 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h2><p>地址类型表示以太坊地址，长度为20字节。地址可以使用<code>.balance</code>方法获得余额，也可以使用<code>.transfer</code>方法将余额转到另一个地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address x = <span class="number">0x212</span>;</span><br><span class="line">address myAddress = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x.<span class="property">balance</span> &lt; <span class="number">10</span> &amp;&amp; myAddress.<span class="property">balance</span> &gt;= <span class="number">10</span>) </span><br><span class="line">    x.<span class="title function_">transfer</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="引用类型-复合数据类型"><a href="#引用类型-复合数据类型" class="headerlink" title="引用类型&#x2F;复合数据类型"></a>引用类型&#x2F;复合数据类型</h2><p>Solidity中，有一些数据类型由值类型组合而成，相比于简单的值类型，这些类型通常通过名称引用，被称为引用类型。</p><p>引用类型包括：</p><ul><li>数组 (字符串与bytes是特殊的数组，所以也是引用类型)</li><li>struct (结构体)</li><li>map (映射)</li></ul><p>“<code>undefined</code>”或“<code>null</code>”值的概念在Solidity中不存在，但是新声明的变量总是有一个 默认值 ，具体的默认值跟类型相关。 要处理任何意外的值，应该使用错误处理来恢复整个交易，或者返回一个带有第二个<code>bool</code> 值的元组表示成功。</p><h2 id="bool-布尔类型"><a href="#bool-布尔类型" class="headerlink" title="bool&#x2F;布尔类型"></a><strong>bool&#x2F;布尔类型</strong></h2><p>布尔值的取值范围为 true 和 false 。</p><p>默认值：<code>false</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">  error NotEqual(bool A,bool B);</span><br><span class="line">	bool public A; // false</span><br><span class="line">	bool public B = true;	//true</span><br><span class="line">  	// require(A==B,&quot;A not equal B&quot;);</span><br><span class="line"></span><br><span class="line">  if (A != B) &#123;</span><br><span class="line">    error NotEqual(A,B);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符：<br>●!（逻辑非）<br>●&amp;&amp; （逻辑与， “and” ）<br>●|| （逻辑或， “or” ）<br>●&#x3D;&#x3D; （等于）<br>●!&#x3D; （不等于）</p><h2 id="int、uint-整数类型"><a href="#int、uint-整数类型" class="headerlink" title="int、uint&#x2F;整数类型"></a><strong>int、uint&#x2F;整数类型</strong></h2><blockquote><p><code>int/uint：</code>变长的<strong>有符号</strong>或<strong>无符号</strong>整型。变量支持的步长以<code>8</code>递增，支持从<code>uint8</code>到<code>uint256</code>，以及<code>int8</code>到<code>int256</code>。需要注意的是，<code>uint</code>和<code>int</code>默认代表的是<code>uint256</code>和<code>int256</code>。</p></blockquote><p><code>int</code> 有符号整型(包含负数)</p><p>默认为<code>int256</code></p><p>不同位长的整形范围如下：</p><ul><li><code>int8</code> 取值范围：-(2 ** 7)到 2 ** 7 -1</li><li><code>int16</code>取值范围：-(2 ** 15)到 2 ** 15 -1</li><li>…</li><li><code>intX</code>取值范围：-(2**<code>X</code>-1)到 2**(<code>X</code>-1) -1</li><li><code>int256</code>取值范围：-(2 ** 255)到 2 ** 255 -1</li></ul><p><code>uint</code> 无符号整型</p><p>默认为<code>uint256</code></p><p>不同位长的整形范围如下：</p><ul><li><code>uint8</code>取值范围：0 到 2 ** 8 - 1</li><li><code>uint16</code>取值范围：0 到 2 ** 16 - 1</li><li>…</li><li><code>uintX</code>取值范围：0 到 2 ** <code>X</code> - 1</li><li><code>uint256</code>取值范围：0 到 2 ** 256 - 1</li></ul><p>对于整形 X，可以使用 type(X).min 和 type(X).max 去获取这个类型的最小值与最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestIntval &#123;</span><br><span class="line">  	int8 public i8 = -1;</span><br><span class="line">    int public i256 = 456;</span><br><span class="line">    int public i = -123; // int 等同于 int256</span><br><span class="line">    // int 的最大最小值</span><br><span class="line">    int public minInt = type(int).min;</span><br><span class="line">    int public maxInt = type(int).max;</span><br><span class="line"></span><br><span class="line">    uint8 public u8 = 1;</span><br><span class="line">    uint256 public u256 = 456;</span><br><span class="line">    uint public u = 123; // uint  等同于 uint256 </span><br><span class="line">		// uint 的最大最小值</span><br><span class="line">    uint public minUInt = type(uint).min;</span><br><span class="line">    uint public maxUInt = type(uint).max;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    function mini() public pure returns(uint8)&#123;</span><br><span class="line">        return type(uint8).max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="address-地址"><a href="#address-地址" class="headerlink" title="address&#x2F;地址"></a><strong>address&#x2F;地址</strong></h2><p>默认值: 0x0000000000000000000000000000000000000000</p><p>20字节的16进制地址用来表示一个账户 或者合约地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestAddress &#123;</span><br><span class="line">    //与其他机器语言相区别的类型就是这个address 类型，160-bit/20byte</span><br><span class="line">    address public myAddr = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;</span><br><span class="line">    //合约自己的地址</span><br><span class="line">    address contractAddress = address(this);</span><br><span class="line">    //跟普通的地址类型一样，但多了两个方法 transfer/send 这两个方法后面章节会讲到</span><br><span class="line">    // address sender = payable(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);</span><br><span class="line">  	//可以使用 balance 属性来查询一个地址的余额</span><br><span class="line">    function getBalance()</span><br><span class="line">        public view</span><br><span class="line">        returns (uint256, uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        require(myAddr.balance &lt; contractAddress.balance, &quot;1 must lg 2&quot;);</span><br><span class="line">        return (myAddr.balance, contractAddress.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bytes-字节数组"><a href="#bytes-字节数组" class="headerlink" title="bytes&#x2F;字节数组"></a><strong>bytes&#x2F;字节数组</strong></h2><p>在计算机中的最小存储单位是 bit(位)</p><ul><li><p>1byte等于8位</p></li><li><p>Solidity中，byte可以赋值为</p></li><li><ul><li>16进制数字</li><li>单引号的单个或多个字符</li></ul></li></ul><p>定长字节数组</p><p>bytes1 后面数字1是表示1字节 bytes默认等于bytes1<br>Bytes2 后面数字2是表示2字节<br>Bytes3 后面数字3是表示3字节<br>bytes4 后面数字4是表示4字节</p><p>…</p><p>bytes32 后面数字32是表示32字节</p><p>bytes32 等价于 int256或uint256 的位数</p><p>成员变量</p><p><code>.length</code> 表示这个字节数组的长度（只读）</p><h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string&#x2F;字符串"></a><strong>string&#x2F;字符串</strong></h2><ol><li>中文特殊字符需要用<code>unicode</code>编码</li><li>通过concat 方法进行拼接</li><li>bytes 和 string之间转化</li><li><code>string</code>字符串不能通过<code>length</code>方法获取其长度。</li><li><code>keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))</code> 可以通过这个方法比较两个字符串是否相等。</li><li><code>abi.encodePacked(s1, s2)</code>:通过这个方法进行字符串合并拼接。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestAddress &#123;</span><br><span class="line">    string public str1 = &quot;123&quot;;</span><br><span class="line">    // 中文不适用unicode编码报错</span><br><span class="line">    // string public str2 = =&quot;你好&quot;;</span><br><span class="line">    string public str2 = unicode&quot;abc&quot;;</span><br><span class="line">    function concat() public view returns(string memory) &#123;</span><br><span class="line">        string memory result = string.concat(str1,str2);</span><br><span class="line">        return  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function caoncat2(string memory _a, string memory _b) public pure returns(string memory) &#123;</span><br><span class="line">        return string.concat(_a,_b);</span><br><span class="line">    &#125;</span><br><span class="line">     function caoncat3(string memory _a, string memory _b) public pure returns(bytes memory) &#123;</span><br><span class="line">          bytes memory _ba = bytes(_a);</span><br><span class="line">        bytes memory _bb = bytes(_b);</span><br><span class="line">        return bytes.concat(_ba,_bb);</span><br><span class="line">    &#125;</span><br><span class="line">      function caoncat4(string memory _a, string memory _b) public pure returns(string memory) &#123;</span><br><span class="line">        bytes memory _ba = bytes(_a);</span><br><span class="line">        bytes memory _bb = bytes(_b);</span><br><span class="line">        return string(bytes.concat(_ba,_bb));</span><br><span class="line">    &#125;</span><br><span class="line">     // 比较s1和s2是否相等，相等返回true，不相等返回false</span><br><span class="line">    function compareEqual(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;   </span><br><span class="line">        // 不支持字符直接比较</span><br><span class="line">        return s1 == s2;</span><br><span class="line">        // return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将s1和s2合并为一个字节数组</span><br><span class="line">    function mergeS1AndS2ReturnBytes(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return abi.encodePacked(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将s1和s2合并为一个字节数组转换为string</span><br><span class="line">    function mergeS1AndS2ReturnString(string memory s1, string memory s2)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (string memory)</span><br><span class="line">    &#123;</span><br><span class="line">        return string(abi.encodePacked(s1, s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enum-枚举"><a href="#Enum-枚举" class="headerlink" title="Enum(枚举)"></a>Enum(枚举)</h2><p>枚举将一个变量的取值限制为几个预定义值中的一个。精确使用枚举类型有助于减少代码中的bug。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ontract UserState &#123;</span><br><span class="line">  // 枚举</span><br><span class="line">  //默认值是列表中的第一个元素</span><br><span class="line">  enum State &#123; </span><br><span class="line">    Online,  	// 0</span><br><span class="line">    Offline,	// 1</span><br><span class="line">    Unknown		// 2</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  State public status;</span><br><span class="line">  function get() public view returns (State) &#123;</span><br><span class="line">      return status;</span><br><span class="line">  &#125;</span><br><span class="line">  // 通过将uint传递到输入来更新状态</span><br><span class="line">  function set(State _status) public &#123;</span><br><span class="line">      status = _status;</span><br><span class="line">  &#125;</span><br><span class="line">  // 也可以是这样确定属性的更新</span><br><span class="line">  function off() public &#123;</span><br><span class="line">      status = State.Offline;</span><br><span class="line">  &#125;</span><br><span class="line">  // delete 将枚举重置为其第一个值 0</span><br><span class="line">  function reset() public &#123;</span><br><span class="line">      delete status;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array-数组"><a href="#array-数组" class="headerlink" title="array&#x2F;数组"></a><strong>array&#x2F;数组</strong></h2><blockquote><p>T[k]: 元素类型为T，固定长度为K的数组 uint[5]</p><p>T[]: 元素类型为T, 长度可以动态调整</p></blockquote><h3 id="一、固定长度的数组（Arrays）"><a href="#一、固定长度的数组（Arrays）" class="headerlink" title="一、固定长度的数组（Arrays）"></a>一、固定长度的数组（Arrays）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract MappingTest &#123;</span><br><span class="line">    // 创建定长数组</span><br><span class="line">    uint256[5] public arr = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">    // 定长数组求和</span><br><span class="line">    function getAll() public view returns (uint256) &#123;</span><br><span class="line">        uint256 num = 0;</span><br><span class="line">        for (uint256 i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            num += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint256[5] memory) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取定长数组长度</span><br><span class="line">    function getLenth() public view returns (uint256) &#123;</span><br><span class="line">        return arr.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改长度失败</span><br><span class="line">    function changeLenth() public &#123;</span><br><span class="line">        // arr.length = 7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改内部数据</span><br><span class="line">    function change(uint256 _idx, uint256 _val) public &#123;</span><br><span class="line">        arr[_idx] = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // push 修改</span><br><span class="line">    // function change(uint256 _val) public &#123;</span><br><span class="line">    //     arr.push(_val);</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、可变长度的Arrays"><a href="#二、可变长度的Arrays" class="headerlink" title="二、可变长度的Arrays"></a>二、可变长度的Arrays</h3><p><code>uint [] T = [1,2,3,4,5]</code>，这句代码表示声明了一个可变长度的<code>T</code>数组，因为我们给它初始化了<code>5</code>个无符号整数，所以它的长度默认为<code>5</code>。</p><p><code>&gt;=0.5.0</code>的版本中<code>length</code>方法只读，不可修改。 5版本之前支持length属性修改，缺失的以0补位</p><p><img src="https://gitee.com/fcjun/image/raw/master/img/202212141509596.png" alt="image-20221214150932547"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint [] T = [1,2,3,4,5];</span><br></pre></td></tr></table></figure><h3 id="三、二维数组-数组里面放数组"><a href="#三、二维数组-数组里面放数组" class="headerlink" title="三、二维数组 - 数组里面放数组"></a>三、二维数组 - 数组里面放数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint256[2][3] T = [[1, 2], [3, 4], [5, 6]];</span><br><span class="line"></span><br><span class="line">    function T_len() public view returns (uint256) &#123;</span><br><span class="line">        return T.length; // uint256: 3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     function getT() public view returns (uint256[2][3] memory) &#123;</span><br><span class="line">        return T;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    function change() public &#123;</span><br><span class="line">        T[1][0] = 55;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>uint [2][3] T = [[1,2],[3,4],[5,6]]</code>这是一个三行两列的数组，你会发现和Java、C语言等的其它语言中二位数组里面的列和行之间的顺序刚好相反。在其它语言中，上面的内容应该是这么存储<code>uint [2][3] T = [[1,2,3],[4,5,6]]</code>。</p><p>上面的<code>数组T</code>是<code>storage</code>类型的数组，对于<code>storage</code>类型的数组，数组里面可以存放任意类型的值（比如：其它数组，结构体，字典／映射等等）。对于<code>memory</code>类型的数组，如果它是一个<code>public</code>类型的函数的参数，那么它里面的内容不能是一个<code>mapping(映射／字典)</code>，并且它必须是一个<code>ABI</code>类型。</p><h3 id="四、数组字面量-Array-Literals-内联数组-Inline-Arrays"><a href="#四、数组字面量-Array-Literals-内联数组-Inline-Arrays" class="headerlink" title="四、数组字面量 Array Literals &#x2F; 内联数组 Inline Arrays"></a>四、数组字面量 Array Literals &#x2F; 内联数组 Inline Arrays</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line">contract C &#123;</span><br><span class="line">    </span><br><span class="line">    function f() pure public &#123;</span><br><span class="line">        g([1, 2, 3]); </span><br><span class="line">        g([uint(1),2,3])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function g(uint[3] memory _data) pure public &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><blockquote><p>通过基本数据类型来组合成自定义复杂的数据类型</p></blockquote><p>语法结构:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct 关键字  结构体名称 &#123;</span><br><span class="line">	类型1  属性名1;</span><br><span class="line">	类型2  属性名2；</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">	uint8 age;</span><br><span class="line">	string id;</span><br><span class="line">	string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建结构变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结构体 变量名 = 结构体(属性1，属性2，...)</span><br><span class="line">结构体 变量名 = 结构体(&#123;属性1：value1，属性2：value2Ï&#125;)</span><br><span class="line"></span><br><span class="line">Person student1 = Person(18,1,&quot;柯南&quot;)；</span><br><span class="line">Person student2 = Person(&#123;age:17, id: 2, name: &quot;迪迦Ï&quot;&#125;)</span><br></pre></td></tr></table></figure><p>修改结构体变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setStudent(uint _age, string _name) public &#123;</span><br><span class="line">	student1.age = _age</span><br><span class="line">	student1.name = _name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中返回结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getStudent() public view returns(Person) &#123;</span><br><span class="line">	return student1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">contract Structs &#123;</span><br><span class="line">    struct Todo &#123;</span><br><span class="line">        string text;</span><br><span class="line">        bool completed;</span><br><span class="line">    &#125;</span><br><span class="line">    // 结构体数组</span><br><span class="line">  </span><br><span class="line">    Todo[] public todos;</span><br><span class="line"></span><br><span class="line">    // 初始化结构的3种方法</span><br><span class="line">    function create(string calldata _text) public &#123;</span><br><span class="line">        // 1.像函数一样调用它</span><br><span class="line">        todos.push(Todo(_text, false));</span><br><span class="line">        // 2. 键值对</span><br><span class="line">        todos.push(Todo(&#123;text: _text, completed: false&#125;));</span><br><span class="line">        // 3.初始化一个空结构，然后更新它</span><br><span class="line">        Todo memory todo;</span><br><span class="line">        todo.text = _text;</span><br><span class="line">        todos.push(todo);// completed 没有定义,默认为 false</span><br><span class="line">    &#125;</span><br><span class="line">    //通过索引获取结构体数组中一个元素,并更新内部的属性</span><br><span class="line">    function update(uint _index) public &#123;</span><br><span class="line">        Todo storage todo = todos[_index];</span><br><span class="line">        todo.completed = !todo.completed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典／映射（Mappings"><a href="#字典／映射（Mappings" class="headerlink" title="字典／映射（Mappings)"></a>字典／映射（Mappings)</h2><blockquote><p>与数组和结构体一样，映射也是引用类型。</p><p>是一个一对一键值存储关系。</p><p>可以理解成js中的对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mapping</span>(<span class="function"><span class="params">_KeyType</span> =&gt;</span> _ValueType)</span><br></pre></td></tr></table></figure><ul><li><code>_KeyType</code> – 可以是任何内置类型，或者bytes和字符串。不允许使用引用类型或复杂对象。</li><li><code>_ValueType</code> – 可以是任何类型。</li></ul><p><strong>注意</strong></p><ul><li>映射的数据位置(data location)只能是storage，通常用于状态变量。</li><li>映射可以标记为public，Solidity 自动为它创建getter。</li><li>mapping 不能直接在函数返回</li></ul><p>创建mapping</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract MappingTest &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function update(uint256 _amount) public &#123;</span><br><span class="line">        balances[msg.sender] = _amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getAmount() public view  returns(uint)&#123;</span><br><span class="line">        return balances[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract LedgerBalance &#123;</span><br><span class="line">   mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">   function updateBalance(uint newBalance) public &#123;</span><br><span class="line">      balances[msg.sender] = newBalance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Updater &#123;</span><br><span class="line">   function updateBalance() public returns (uint) &#123;</span><br><span class="line">      LedgerBalance ledgerBalance = new LedgerBalance();</span><br><span class="line">      ledgerBalance.updateBalance(10);</span><br><span class="line">      return ledgerBalance.balances(address(this));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract Mapping &#123;</span><br><span class="line">    //从地址到uint的映射</span><br><span class="line">    mapping(address =&gt; uint) public myMap;</span><br><span class="line"></span><br><span class="line">    function get(address _addr) public view returns (uint) &#123;</span><br><span class="line">        //映射始终返回一个值。</span><br><span class="line">				//如果从未设置该值，它将返回默认值。</span><br><span class="line">        return myMap[_addr];</span><br><span class="line">    &#125;</span><br><span class="line">    // 更新此地址的值 	</span><br><span class="line">    function set(address _addr, uint _i) public &#123;</span><br><span class="line">        myMap[_addr] = _i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function remove(address _addr) public &#123;</span><br><span class="line">				//将值重置为默认值</span><br><span class="line">        delete myMap[_addr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//嵌套 mapping</span><br><span class="line">contract NestedMapping &#123;</span><br><span class="line">    //嵌套映射（从地址映射到另一个映射）</span><br><span class="line">    mapping(address =&gt; mapping(uint =&gt; bool)) public nested;</span><br><span class="line"></span><br><span class="line">    function get(address _addr1, uint _i) public view returns (bool) &#123;</span><br><span class="line">        // 可以从嵌套映射中获取值</span><br><span class="line">        return nested[_addr1][_i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set(</span><br><span class="line">        address _addr1,</span><br><span class="line">        uint _i,</span><br><span class="line">        bool _boo</span><br><span class="line">    ) public &#123;</span><br><span class="line">        nested[_addr1][_i] = _boo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除 mapping 的一个元素</span><br><span class="line">    function remove(address _addr1, uint _i) public &#123;</span><br><span class="line">        delete nested[_addr1][_i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Solidity运算符"><a href="#Solidity运算符" class="headerlink" title="Solidity运算符"></a>Solidity运算符</h1><h3 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h3><table><thead><tr><th align="left">序号</th><th align="left">运算符与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>+ (加)</strong> 求和 <strong>例:</strong> A + B &#x3D; 30</td></tr><tr><td align="left">2</td><td align="left"><strong>– (减)</strong> 相减 <strong>例:</strong> A – B &#x3D; -10</td></tr><tr><td align="left">3</td><td align="left">*** (乘)** 相乘 <strong>例:</strong> A * B &#x3D; 200</td></tr><tr><td align="left">4</td><td align="left"><strong>&#x2F; (除)</strong> 相除 <strong>例:</strong> B &#x2F; A &#x3D; 2</td></tr><tr><td align="left">5</td><td align="left"><strong>% (取模)</strong> 取模运算 <strong>例:</strong> B % A &#x3D; 0</td></tr><tr><td align="left">6</td><td align="left"><strong>++ (递增)</strong> 递增 <strong>例:</strong> A++ &#x3D; 11</td></tr><tr><td align="left">7</td><td align="left"><strong>— (递减)</strong> 递减 <strong>例:</strong> A– &#x3D; 9</td></tr></tbody></table><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table><thead><tr><th align="left">序号</th><th align="left">运算符与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>&#x3D;&#x3D; (等于)</strong></td></tr><tr><td align="left">2</td><td align="left"><strong>!&#x3D; (不等于)</strong></td></tr><tr><td align="left">3</td><td align="left"><strong>&gt; (大于)</strong></td></tr><tr><td align="left">4</td><td align="left"><strong>&lt; (小于)</strong></td></tr><tr><td align="left">5</td><td align="left"><strong>&gt;&#x3D; (大于等于)</strong></td></tr><tr><td align="left">6</td><td align="left"><strong>&lt;&#x3D; (小于等于)</strong></td></tr></tbody></table><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><table><thead><tr><th align="left">序号</th><th align="left">运算符与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>&amp;&amp; (逻辑与)</strong> 如果两个操作数都非零，则条件为真。 <strong>例:</strong> (A &amp;&amp; B) 为真</td></tr><tr><td align="left">2</td><td align="left"><strong>|| (逻辑或)</strong> 如果这两个操作数中有一个非零，则条件为真。 <strong>例:</strong> (A || B) 为真</td></tr><tr><td align="left">3</td><td align="left"><strong>! (逻辑非)</strong> 反转操作数的逻辑状态。如果条件为真，则逻辑非操作将使其为假。 <strong>例:</strong> ! (A &amp;&amp; B) 为假</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th align="left">序号</th><th align="left">运算符与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>&amp; (位与)</strong> 对其整数参数的每个位执行位与操作。 <strong>例:</strong> (A &amp; B) 为 2.</td></tr><tr><td align="left">2</td><td align="left"><strong>| (位或)</strong> 对其整数参数的每个位执行位或操作。 <strong>例:</strong> (A | B) 为 3.</td></tr><tr><td align="left">3</td><td align="left"><strong>^ (位异或)</strong> 对其整数参数的每个位执行位异或操作。 <strong>例:</strong> (A ^ B) 为 1.</td></tr><tr><td align="left">4</td><td align="left"><strong>~ (位非)</strong> 一元操作符，反转操作数中的所有位。 <strong>例:</strong> (~B) 为 -4.</td></tr><tr><td align="left">5</td><td align="left"><strong>&lt;&lt; (左移位))</strong> 将第一个操作数中的所有位向左移动，移动的位置数由第二个操作数指定，新的位由0填充。将一个值向左移动一个位置相当于乘以2，移动两个位置相当于乘以4，以此类推。 <strong>例:</strong> (A &lt;&lt; 1) 为 4.</td></tr><tr><td align="left">6</td><td align="left"><strong>&gt;&gt; (右移位)</strong> 左操作数的值向右移动，移动位置数量由右操作数指定 <strong>例:</strong> (A &gt;&gt; 1) 为 1.</td></tr></tbody></table><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>solidity 支持的赋值运算符，如下表所示：</p><table><thead><tr><th align="left">序号</th><th align="left">运算符与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>&#x3D; (简单赋值)</strong> 将右侧操作数的值赋给左侧操作数 <strong>例:</strong> C &#x3D; A + B 表示 A + B 赋给 C</td></tr><tr><td align="left">2</td><td align="left"><strong>+&#x3D; (相加赋值)</strong> 将右操作数添加到左操作数并将结果赋给左操作数。 <strong>例:</strong> C +&#x3D; A 等价于 C &#x3D; C + A</td></tr><tr><td align="left">3</td><td align="left"><strong>−&#x3D; (相减赋值)</strong> 从左操作数减去右操作数并将结果赋给左操作数。 <strong>例:</strong> C -&#x3D; A 等价于 C &#x3D; C – A</td></tr><tr><td align="left">4</td><td align="left">***&#x3D; (相乘赋值)** 将右操作数与左操作数相乘，并将结果赋给左操作数。 <strong>例:</strong> C *&#x3D; A 等价于 C &#x3D; C * A</td></tr><tr><td align="left">5</td><td align="left"><strong>&#x2F;&#x3D; (相除赋值)</strong> 将左操作数与右操作数分开，并将结果分配给左操作数。 <strong>例:</strong> C &#x2F;&#x3D; A 等价于 C &#x3D; C &#x2F; A</td></tr><tr><td align="left">6</td><td align="left"><strong>%&#x3D; (取模赋值)</strong> 使用两个操作数取模，并将结果赋给左边的操作数。 <strong>例:</strong> C %&#x3D; A 等价于 C &#x3D; C % A</td></tr></tbody></table><blockquote><p><strong>注意</strong> – 同样的逻辑也适用于位运算符，因此它们将变成<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>|=</code>和<code>^=</code>。</p></blockquote><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><table><thead><tr><th align="left">序号</th><th align="left">运算符与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>? : (条件运算符 )</strong> 如果条件为真 ? 则取值X : 否则值Y</td></tr></tbody></table><h1 id="Solidity循环语句"><a href="#Solidity循环语句" class="headerlink" title="Solidity循环语句"></a>Solidity循环语句</h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (表达式) &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">        int256 start = 1;</span><br><span class="line">        while (start &lt;= max) &#123;</span><br><span class="line">            start++;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h2><p>Solidity 中， do…while循环的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125; while (表达式);</span><br><span class="line">注意: 不要漏掉do后面的分号。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract TestBool &#123;</span><br><span class="line">   uint public num  = 10;</span><br><span class="line">   function test () public returns(uint) &#123;</span><br><span class="line">       int  start = 1;</span><br><span class="line">       int  max = 10;</span><br><span class="line">       do&#123;</span><br><span class="line">         start ++;</span><br><span class="line">         num ++;</span><br><span class="line">       &#125;while(start &lt;=max);</span><br><span class="line">       return num;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (初始化; 测试条件; 迭代语句) &#123;</span><br><span class="line">   被执行语句(如果表示为真)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">     for(int256 start = 1; start&lt;max; start ++) &#123;</span><br><span class="line">         num ++;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract TestBool &#123;</span><br><span class="line">    uint256 public num = 10;</span><br><span class="line"></span><br><span class="line">    function test(int max) public &#123;</span><br><span class="line">     for(int256 start = 1; start&lt;max; start ++) &#123;</span><br><span class="line">         if(start == 1) &#123;</span><br><span class="line">            //  break;  // 跳出循环 num 10</span><br><span class="line">            continue; // 跳出本次循环</span><br><span class="line">        &#125;</span><br><span class="line">         num ++;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Solidity条件语句"><a href="#Solidity条件语句" class="headerlink" title="Solidity条件语句"></a>Solidity条件语句</h1><p>Solidity支持条件语句，让程序可以根据条件执行不同的操作。条件语句包括：</p><ul><li><code>if</code></li><li><code>if...else</code></li><li><code>if...else if</code></li></ul><p><img src="https://gitee.com/fcjun/image/raw/master/img/image-20221208161811890.png" alt="image-20221208161811890"></p><h1 id="Solidity中的函数"><a href="#Solidity中的函数" class="headerlink" title="Solidity中的函数"></a>Solidity中的函数</h1><h2 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h2><blockquote><p>函数修饰符用于修改函数的行为。例如，向函数添加条件限制。</p><p>修饰符定义中出现特殊符号<code>_</code>的地方，用于插入函数体。如果在调用此函数时，满足了修饰符的条件，则执行该函数，否则将抛出异常。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Owner &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    uint256 price = 10;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 定义修饰符 onlyOwner 不带参数</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用修饰符 onlyOwner 限制只有发布者才能调用</span><br><span class="line">    function changePrice(uint256 _price)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        onlyOwner</span><br><span class="line">        returns (address, uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return (owner, _price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="视图函数（view）"><a href="#视图函数（view）" class="headerlink" title="视图函数（view）"></a>视图函数（view）</h2><blockquote><p>View(视图)函数 使用状态变量，但是不修改状态</p></blockquote><p>如果函数中存在以下语句，则被视为修改状态，编译器将抛出警告。</p><ul><li>修改状态变量。</li><li>触发事件。</li><li>创建合约。</li><li>使用<code>selfdestruct</code>。</li><li>发送以太。</li><li>调用任何不是视图函数或纯函数的函数</li><li>使用底层调用</li><li>使用包含某些操作码的内联程序集。</li></ul><p>Getter方法是默认的视图函数。声明视图函数，可以在函数声明里，添加<code>view</code>关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getResult() public view returns (uint256, uint256) &#123;</span><br><span class="line">        uint256 a = 1; // 局部变量</span><br><span class="line">        uint256 b = 2;</span><br><span class="line">        uint256 product = a * b;</span><br><span class="line">        uint256 sum = a + b;</span><br><span class="line">        return (product, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="纯函数（Pure）"><a href="#纯函数（Pure）" class="headerlink" title="纯函数（Pure）"></a>纯函数（Pure）</h2><blockquote><p>Pure(纯)函数<strong>不读取</strong>或修改状态。</p><p>声明纯函数，可以在函数声明里，添加<code>pure</code>关键字。</p></blockquote><p>如果函数中存在以下语句，则被视为读取状态，编译器将抛出警告</p><ul><li>读取状态变量。</li><li>访问 <code>address(this).balance</code> 或 <code>&lt;address&gt;.balance</code></li><li>访问任何区块、交易、msg等特殊变量(msg.sig 与 msg.data 允许读取)。</li><li>调用任何不是纯函数的函数。</li><li>使用包含特定操作码的内联程序集。</li></ul><p>如果发生错误，纯函数可以使用<code>revert()</code>和<code>require()</code>函数来还原潜在的状态更改。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><blockquote><p>同一个作用域内，相同函数名可以定义多个函数。这些函数的参数(参数类型或参数数量)必须不一样。仅仅是返回值不一样不被允许。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    function getSum(uint256 a, uint256 b) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSum(</span><br><span class="line">        uint256 a,</span><br><span class="line">        uint256 b,</span><br><span class="line">        uint256 c</span><br><span class="line">    ) public pure returns (uint256) &#123;</span><br><span class="line">        return a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h2><blockquote><p>Solidity 提供了常用的加密函数。以下是一些重要函数：</p><ul><li><code>keccak256(bytes memory) returns (bytes32)</code> 计算输入的Keccak-256散列。</li><li><code>sha256(bytes memory) returns (bytes32)</code> 计算输入的SHA-256散列。</li><li><code>ripemd160(bytes memory) returns (bytes20)</code> 计算输入的RIPEMD-160散列。</li><li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>从椭圆曲线签名中恢复与公钥相关的地址，或在出错时返回零。函数参数对应于签名的ECDSA值: r – 签名的前32字节; s: 签名的第二个32字节; v: 签名的最后一个字节。这个方法返回一个地址。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract Test &#123;   </span><br><span class="line">   function callKeccak256() public pure returns(bytes32 result)&#123;</span><br><span class="line">      return keccak256(&quot;ABC&quot;);</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><h2 id="合约继承"><a href="#合约继承" class="headerlink" title="合约继承"></a>合约继承</h2><blockquote><p>就像Java、C++中，类的继承一样，Solidity中，合约继承是扩展合约功能的一种方式。Solidity支持单继承和多继承。</p></blockquote><p>Solidity中，合约继承的重要特点：</p><ul><li>派生合约可以访问父合约的所有非私有成员，包括内部方法和状态变量。但是不允许使用<code>this</code>。</li><li>如果函数签名保持不变，则允许函数重写。如果输出参数不同，编译将失败。</li><li>可以使用<code>super</code>关键字或父合同名称调用父合同的函数。</li><li>在多重继承的情况下，使用<code>super</code>的父合约函数调用，优先选择被最多继承的合约。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint256 private data;</span><br><span class="line">    uint256 public info;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        info = 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function increment(uint256 a) private pure returns (uint256) &#123;</span><br><span class="line">        return a + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function updateData(uint256 a) public &#123;</span><br><span class="line">        data = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getData() public view returns (uint256) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function compute(uint256 a, uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Test is Base &#123;</span><br><span class="line">    uint256 private result;</span><br><span class="line">    Base private base;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        base = new Base();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getComputedResult() public &#123;</span><br><span class="line">        result = compute(3, 5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getResult() public view returns (uint256) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote><p>构造函数是使用<code>construct</code>关键字声明的特殊函数，用于初始化合约的状态变量。合约中构造函数是可选的，可以省略。</p></blockquote><p>构造函数有以下重要特性：</p><ul><li>一个合约只能有一个构造函数。</li><li>构造函数在创建合约时执行一次，用于初始化合约状态。</li><li>在执行构造函数之后，合约最终代码被部署到区块链。合约最终代码包括公共函数和可通过公共函数访问的代码。构造函数代码或仅由构造函数使用的任何内部方法不包括在最终代码中。</li><li>构造函数可以是公共的，也可以是内部的。</li><li>内部构造函数将合约标记为抽象合约。</li><li>如果没有定义构造函数，则使用默认构造函数。</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://angelxyj.github.io">许小墨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://angelxyj.github.io/posts/14d570ad.html">https://angelxyj.github.io/posts/14d570ad.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://angelxyj.github.io" target="_blank">许小墨のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/%E6%A0%87%E7%AD%BE/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/%E6%A0%87%E7%AD%BE/Web3-0/">Web3.0</a><a class="post-meta__tags" href="/%E6%A0%87%E7%AD%BE/solidity/">solidity</a></div><div class="post_share"><div class="social-share" data-image="/img/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>感谢支持！</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/c9456675.html" title="Vue3.x——组合式API"><img class="cover" src="/img/6.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vue3.x——组合式API</div></div></a></div><div class="next-post pull-right"><a href="/posts/e639fe97.html" title="git-note"><img class="cover" src="/img/jujingyi.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">git-note</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div class="comment-switch"><span class="first-comment">Waline</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">许小墨</div><div class="author-info__description">全栈攻城狮的基本素养</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">198</div></a><a href="/%E6%A0%87%E7%AD%BE/"><div class="headline">标签</div><div class="length-num">183</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">42</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Angelxyj"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Angelxyj" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1440023258@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Solidty-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-number">1.</span> <span class="toc-text">Solidty 开发环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hardhat"><span class="toc-number">1.1.</span> <span class="toc-text">Hardhat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Truffle"><span class="toc-number">1.2.</span> <span class="toc-text">Truffle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Embark"><span class="toc-number">1.3.</span> <span class="toc-text">Embark</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Remix%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">Remix基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Remix%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.</span> <span class="toc-text">Remix基本功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">合约创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E7%BC%96%E8%AF%91"><span class="toc-number">2.3.</span> <span class="toc-text">合约编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2"><span class="toc-number">2.4.</span> <span class="toc-text">合约部署</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E8%B0%83%E8%AF%95"><span class="toc-number">2.5.</span> <span class="toc-text">合约调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2ReMix-IDE"><span class="toc-number">3.</span> <span class="toc-text">本地部署ReMix IDE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85"><span class="toc-number">3.1.</span> <span class="toc-text">Docker方式安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-compose%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85"><span class="toc-number">3.2.</span> <span class="toc-text">docker-compose方式安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2-Remixd"><span class="toc-number">3.3.</span> <span class="toc-text">部署 Remixd</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Solidity%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.</span> <span class="toc-text">Solidity基础介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%98%E5%82%A8%E5%90%88%E7%BA%A6"><span class="toc-number">4.1.</span> <span class="toc-text">认识一个最简单的存储合约</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.1.1.</span> <span class="toc-text">授权协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solidity%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6"><span class="toc-number">4.1.2.</span> <span class="toc-text">Solidity版本限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">执行原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Api%E6%96%87%E6%A1%A3"><span class="toc-number">4.3.</span> <span class="toc-text">Api文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">4.4.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Solidity-%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.5.</span> <span class="toc-text">Solidity 可见性修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AFErrors"><span class="toc-number">4.7.</span> <span class="toc-text">错误Errors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6Event"><span class="toc-number">4.8.</span> <span class="toc-text">事件Event</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.</span> <span class="toc-text">变量的数据位置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.1.</span> <span class="toc-text">数据位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Storage"><span class="toc-number">5.1.1.</span> <span class="toc-text">Storage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory"><span class="toc-number">5.1.2.</span> <span class="toc-text">Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calldata"><span class="toc-number">5.1.3.</span> <span class="toc-text">Calldata</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack"><span class="toc-number">5.1.4.</span> <span class="toc-text">Stack</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E8%A7%84%E5%88%99"><span class="toc-number">5.2.</span> <span class="toc-text">数据位置规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%991-%E2%80%93-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">规则1 – 状态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%992-%E2%80%93-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.2.2.</span> <span class="toc-text">规则2 – 函数参数与返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%993-%E2%80%93-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.3.</span> <span class="toc-text">规则3 – 局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%994-%E2%80%93-%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.4.</span> <span class="toc-text">规则4 – 外部函数的参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E8%A7%84%E5%88%99"><span class="toc-number">5.3.</span> <span class="toc-text">赋值的数据位置规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Solidity%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">Solidity数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">值类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">地址类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">引用类型&#x2F;复合数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bool-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.4.</span> <span class="toc-text">bool&#x2F;布尔类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int%E3%80%81uint-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.5.</span> <span class="toc-text">int、uint&#x2F;整数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#address-%E5%9C%B0%E5%9D%80"><span class="toc-number">6.6.</span> <span class="toc-text">address&#x2F;地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bytes-%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="toc-number">6.7.</span> <span class="toc-text">bytes&#x2F;字节数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.8.</span> <span class="toc-text">string&#x2F;字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Enum-%E6%9E%9A%E4%B8%BE"><span class="toc-number">6.9.</span> <span class="toc-text">Enum(枚举)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array-%E6%95%B0%E7%BB%84"><span class="toc-number">6.10.</span> <span class="toc-text">array&#x2F;数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%88Arrays%EF%BC%89"><span class="toc-number">6.10.1.</span> <span class="toc-text">一、固定长度的数组（Arrays）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E7%9A%84Arrays"><span class="toc-number">6.10.2.</span> <span class="toc-text">二、可变长度的Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E6%95%B0%E7%BB%84%E9%87%8C%E9%9D%A2%E6%94%BE%E6%95%B0%E7%BB%84"><span class="toc-number">6.10.3.</span> <span class="toc-text">三、二维数组 - 数组里面放数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E7%BB%84%E5%AD%97%E9%9D%A2%E9%87%8F-Array-Literals-%E5%86%85%E8%81%94%E6%95%B0%E7%BB%84-Inline-Arrays"><span class="toc-number">6.10.4.</span> <span class="toc-text">四、数组字面量 Array Literals &#x2F; 内联数组 Inline Arrays</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-struct"><span class="toc-number">6.11.</span> <span class="toc-text">结构体 struct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%EF%BC%8F%E6%98%A0%E5%B0%84%EF%BC%88Mappings"><span class="toc-number">6.12.</span> <span class="toc-text">字典／映射（Mappings)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Solidity%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.</span> <span class="toc-text">Solidity运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF"><span class="toc-number">7.0.1.</span> <span class="toc-text">算术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-number">7.0.2.</span> <span class="toc-text">比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91"><span class="toc-number">7.0.3.</span> <span class="toc-text">逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.0.4.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">7.0.5.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.0.6.</span> <span class="toc-text">条件运算符</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#Solidity%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.</span> <span class="toc-text">Solidity循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#while"><span class="toc-number">8.1.</span> <span class="toc-text">while</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do%E2%80%A6while"><span class="toc-number">8.2.</span> <span class="toc-text">do…while</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for"><span class="toc-number">8.3.</span> <span class="toc-text">for</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break-%E4%B8%8E-continue"><span class="toc-number">8.4.</span> <span class="toc-text">break 与 continue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Solidity%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">9.</span> <span class="toc-text">Solidity条件语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Solidity%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">Solidity中的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">10.1.</span> <span class="toc-text">函数修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%EF%BC%88view%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">视图函数（view）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%88Pure%EF%BC%89"><span class="toc-number">10.3.</span> <span class="toc-text">纯函数（Pure）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">10.4.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0"><span class="toc-number">10.5.</span> <span class="toc-text">加密函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6"><span class="toc-number">11.</span> <span class="toc-text">智能合约</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E7%BB%A7%E6%89%BF"><span class="toc-number">11.1.</span> <span class="toc-text">合约继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.</span> <span class="toc-text">构造函数</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3d9e6dac.html" title="004_鸿蒙如何实现自定义 Canvas？底层如何进行 Ui 的渲染 flutter skia"><img src="/img/14.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="004_鸿蒙如何实现自定义 Canvas？底层如何进行 Ui 的渲染 flutter skia"></a><div class="content"><a class="title" href="/posts/3d9e6dac.html" title="004_鸿蒙如何实现自定义 Canvas？底层如何进行 Ui 的渲染 flutter skia">004_鸿蒙如何实现自定义 Canvas？底层如何进行 Ui 的渲染 flutter skia</a><time datetime="2024-06-12T21:53:42.000Z" title="发表于 2024-06-12 21:53:42">2024-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4f9a63a7.html" title="003_了解过鸿蒙的 Napi 吗？如果我需要编译三方库如何链接？"><img src="/img/18.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="003_了解过鸿蒙的 Napi 吗？如果我需要编译三方库如何链接？"></a><div class="content"><a class="title" href="/posts/4f9a63a7.html" title="003_了解过鸿蒙的 Napi 吗？如果我需要编译三方库如何链接？">003_了解过鸿蒙的 Napi 吗？如果我需要编译三方库如何链接？</a><time datetime="2024-06-12T21:45:44.000Z" title="发表于 2024-06-12 21:45:44">2024-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dda8b3d8.html" title="002_音视频开发，鸿蒙实现播放器的 Ui 部分+底层部分"><img src="/img/jujingyi.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="002_音视频开发，鸿蒙实现播放器的 Ui 部分+底层部分"></a><div class="content"><a class="title" href="/posts/dda8b3d8.html" title="002_音视频开发，鸿蒙实现播放器的 Ui 部分+底层部分">002_音视频开发，鸿蒙实现播放器的 Ui 部分+底层部分</a><time datetime="2024-06-12T21:35:34.000Z" title="发表于 2024-06-12 21:35:34">2024-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1faddbca.html" title="001_组件化开发原理，鸿蒙组件化实现思路"><img src="/img/1.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="001_组件化开发原理，鸿蒙组件化实现思路"></a><div class="content"><a class="title" href="/posts/1faddbca.html" title="001_组件化开发原理，鸿蒙组件化实现思路">001_组件化开发原理，鸿蒙组件化实现思路</a><time datetime="2024-06-12T21:28:54.000Z" title="发表于 2024-06-12 21:28:54">2024-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6d6b0b0f.html" title="019_Gauge"><img src="/img/9.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="019_Gauge"></a><div class="content"><a class="title" href="/posts/6d6b0b0f.html" title="019_Gauge">019_Gauge</a><time datetime="2024-06-12T21:24:14.000Z" title="发表于 2024-06-12 21:24:14">2024-06-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2024 By 许小墨</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_60306931/category_12251529.html">blog</a>!<br><span>备案号：xxxxxx</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach(((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,a="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent,i=mermaid.render(r,a);var m;"string"==typeof i?(m=i,d.insertAdjacentHTML("afterend",m)):i.then((({svg:e})=>{d.insertAdjacentHTML("afterend",e)}))}))},n=()=>{window.loadMermaid?t():getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(t)};btf.addGlobalFn("themeChange",t,"mermaid"),window.pjax?n():document.addEventListener("DOMContentLoaded",n)})()</script><script>(()=>{let n=window.walineFn||null;const e=n=>{const e=n(Object.assign({el:"#waline-wrap",serverURL:"https://xuxiaomo-waline-i53b26l6n-xuxiaomo-xyj.vercel.app/",pageview:!1,dark:'html[data-theme="dark"]',path:window.location.pathname,comment:!1},null));btf.addGlobalFn("pjax",(()=>{e.destroy()}),"destroyWaline")},t=async()=>{if(n)e(n);else{await getCSS("https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css");const{init:t}=await import("https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js");n=t||Waline.init,e(n),window.walineFn=n}};btf.loadComment(document.getElementById("waline-wrap"),t)})()</script><script>(()=>{const t=function(){this.page.url="https://angelxyj.github.io/posts/14d570ad.html",this.page.identifier="/posts/14d570ad.html",this.page.title="solidity入门"},e=()=>{window.DISQUS&&window.DISQUS.reset({reload:!0,config:t})};btf.addGlobalFn("themeChange",e,"disqus");const i=()=>{if(window.DISQUS)e();else{const t=document.createElement("script");t.src="https://xuxiaomo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),document.head.appendChild(t)}};window.loadOtherComment=i})()</script></div><script>window.addEventListener("load",(()=>{const e=e=>{let t="";if(e.length)for(let a=0;a<e.length;a++){t+="<div class='aside-list-item'>";{const n="src";t+=`<a href='${e[a].url}' class='thumbnail'><img ${n}='${e[a].avatar}' alt='${e[a].nick}'></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[a].url}' title='${e[a].content}'>${e[a].content}</a>\n        <div class='name'><span>${e[a].nick} / </span><time datetime="${e[a].date}">${btf.diffDate(e[a].date,!0)}</time></div>\n        </div></div>`}else t+="没有评论";let a=document.querySelector("#card-newest-comments .aside-list");a&&(a.innerHTML=t),window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(a)},t=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const t=saveToLocal.get("waline-newest-comments");t?e(JSON.parse(t)):(async()=>{try{const t=await fetch("https://xuxiaomo-waline-i53b26l6n-xuxiaomo-xyj.vercel.app/api/comment?type=recent&count=6",{method:"GET"}),a=(await t.json()).data.map((e=>{return{content:(t=e.comment,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.objectId,date:e.time||e.insertedAt};var t}));saveToLocal.set("waline-newest-comments",JSON.stringify(a),10/1440),e(a)}catch(e){console.error(e),document.querySelector("#card-newest-comments .aside-list").textContent="无法获取评论，请确认相关配置是否正确"}})()}};t(),document.addEventListener("pjax:complete",t)}))</script><div class="aplayer no-destroy" data-id="8760365089" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="false"></div><script defer src="/live2d-widget/autoload.js"></script><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="true" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="//code.tidio.co/fpezrlnx14lzqj1yzhyigw0j3rkhtyzv.js" async></script><script>(()=>{{let i=!1;const d=()=>{window.tidioChatApi.hide(),i=!1},o=()=>{window.tidioChatApi.open(),window.tidioChatApi.show(),i=!0},t=()=>{window.tidioChatApi.hide(),window.tidioChatApi.on("close",d)};window.tidioChatApi?window.tidioChatApi.on("ready",t):document.addEventListener("tidioChat-ready",t),window.chatBtnFn=()=>{window.tidioChatApi&&(i?d():o())}}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(btf.removeGlobalFnEvent("pjax"),btf.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 糖果屋上新啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍭查看新品🍬</span></a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"✨ 糖果屋上新啦！ 👉",backgroundColor:t,duration:5e5,pos:e,actionText:"🍭查看新品🍬",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",(function(){showNotification()})),window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js")})))</script></div></body></html>